## CPU 스케줄링 개요

- **_운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 CPU 스케줄링이라고 한다._**

- 스케줄링의 목적
  ```
  공정성(Fairness): 모든 프로세스가 CPU 시간을 공평하게 나눠 사용
  처리량(Throughput): 단위 시간당 완료되는 프로세스의 수를 최대화
  응답시간(Response Time): 프로세스가 처음 CPU를 요청한 후 응답을 받는 데 걸리는 시간을 최소화
  반환시간(Turnaround Time): 프로세스가 시작하여 완료될 때까지 걸리는 시간을 최소화
  CPU 이용률(CPU Utilization): CPU가 항상 사용되도록 유지
  ```

### 프로세스 우선순위

- 우선순위가 높은 프로세스란 빨리 처리해야 하는 프로세스들을 의미한다.
  - ex. 입출력 작업이 많은 프로세스
- 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다.
  - 입출력 집중 프로세스 : 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력이 많은 프로세스로, 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르게 된다.
  - CPU 집중 프로세스 : 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스로, 대기 상태보다는 실행 상태에 더 많이 머무르게 된다.
- 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다.
- 프로세스 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 **우선순위**를 부여한다.
- 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

### 스케줄링 큐

- 운영체제가 매번 모든 PCB를 검사하여 먼저 자원을 이용할 프로세스를 결정하는 일은 오랜 시간이 걸리게 된다.
- 그래서 운영체제는 스케줄링 큐로 구현하고 관리한다.
  - **메모리로 적재되고 싶은 프로세스들, CPU를 이용하고 싶은 프로세스들, 특정 입출력장치를 이용하고 싶은 프로세스들을 큐에 삽입하여 줄을 세운다.**
- 준비 큐 : CPU를 이용하고 싶은 프로세스들이 서는 줄
- 대기 큐 : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
  ![스케줄링큐](https://github.com/zhwltlr/CS-Study/assets/100506719/bb37af4d-2912-426c-b92e-48621261cde0)

### 선점형과 비선점형 스케줄링

- 선점형 스케줄링 : 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식을 의미한다.
  - 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.
- 비선점형 스케줄링 : 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 의미한다.
  - 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적지만, 모든 프로세스가 골고루 자원을 사용할 수 없다는 단점이 있다.

## CPU 스케줄링 알고리즘

### 스케줄링 알고리즘의 종류

- 스케줄링 알고리즘의 종류는 매우 다양하다. 운영체제도 저마다 다른 스케줄링 알고리즘을 사용한다.

#### 선입 선처리 스케줄링 (FCFS 스케줄링)

- 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다.
- 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용이 있는 방식이다.
- _호위 효과_

#### 최단 작업 우선 스케줄링 (SJF 스케줄링)

- 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식이다.
- 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될수도 있다.

#### 라운드 로빈 스케줄링

- 선입 선처리 스케줄링에 타임 슬라이스 개념이 더해진 스케줄링 방식이다.
- _타임 슬라이스_ : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 즉, 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링이다.
- _라운드 로빈 스케줄링에서는 타임 슬라이스 크기가 매우 중요_ 하다.
  - 타임 슬라이스가 크면 호위 효과가 생길 여지가 있고, 작으면 문맥 교환에 발생하는 비용이 커진다.

#### 최소 잔여 시간 우선 스케줄링 (SRT 스케줄링)

- 최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식이다.
- 최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있느느 작업 시간이 가장 적은 프로세스가 선택된다.

#### 우선순위 스케줄링

- 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다.
- 우선순위가 높은 프로세스를 우선 처리하는 방식이기에 우선순위가 낮은 프로세스는 계속해서 연기될 수 있다.

  - 이를 *기아 현상*이라 한다.

- 이를 방지 하기 위해 `에이징` 기법을 사용한다.
  - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다..

#### 다단계 큐 스케줄링

- 우선순위 스케줄링의 발전된 형태이다.
- 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리한다.
- 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다.
- 그러나 프로세스들이 큐 사이를 이동할 수 없기 때문에 방식대로라면 우선순위가 낮은 프로세스는 계속 연기될 여지가 있다. 즉, _기아 현상_ 이 발생할 수 있다.

#### 다단계 피드백 큐 스케줄링

- 프로세스들이 큐 사이를 이동할 수 있다.
- 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간(타임 슬라이스) 동안 실행한다.
- 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다. 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선 순위가 낮아진다.
  ![다단계피드백큐](https://github.com/zhwltlr/CS-Study/assets/100506719/dbdb5105-b15f-4d7a-b72a-4f5b598083de)
- 프로세스들이 큐 사이를 이동할 수 있는 방식이기 때문에 오래 기다리는 프로세스들을 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.
- 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져있다.
