## 연속 메모리 할당

프로세스에 연속적인 메모리 공간을 할당하는 방식을 연속 메모리 할당 방식이라고 한다.

### 스와핑

- 메모리에 적재된 프로세스 중 현재 실행되지 않는 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 **스와핑**이라고 한다.
- 프로세스들이 쫓겨나는 보조기억장치의 일부 영역을 _스왑 영역_ 이라고 한다.
- 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옯겨지는 것을 _스왑 아웃_ , 반대로 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 _스왑 인_ 이라고 한다.
  그림
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.

### 메모리 할당

- 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식
- **최초 적합**
  - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.
  - 프로세스가 적재할 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화 할 수 있고 결과적으로 빠른 할당이 가능하다.
  - 그림
- **최적 적합**
  - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.
  - 그림
- **최악 적합**
  - 운영체제가 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.
  - 그림

### 외부 단편화

- 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 위와 같이 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다.
- 프로세스 바깥에 생기는 이러한 빈 공간들은 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고 결국 메모리 낭비로 이어진다.
- 이러한 현상을 **_외부 단편화_** 라고 한다.
  그림
- 위와 같은 상황에 50MB 크기의 프로세스를 적재할 수 없다.
- 이를 해결할 수 있는 대표적인 방안으로 메모리를 **압축**하는 방법이 있다.
- 압축 : 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법이다.
  그림
- 단점 : 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기한다.

## 페이징을 통한 가상 메모리 관리

- **가상 메모리** : 실행하고자 하는 프로그램은 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

### 페이징이란

- 프로세스의 논리 주소 공간을 *페이지*라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 *프레임*이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
- 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃되고, 실행에 필요한 페이지들은 메모리로 스왑 인 되는 것이다. (페이지 아웃 / 페이지 인 이라고도 한다.)
  그림
- 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.
- 이와 같은 방식을 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.

### 페이지 테이블

- 프로세스가 메모리에 불연속적으로 배치되면 CPU입장에서 다음 실행할 명령어 위치를 찾기 어려워 진다.
- 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 **페이지 테이블**을 이용한다.
- 페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려준다.
  그림
- 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다.
- CPU 내의 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.
  그림
- 문제점 : 메모리 접근 시간이 두배로 늘어난다. 메모리에 있는 페이지 테이블을 보고, 그렇게 알게 된 프레임에 접근하기 위해 한 번 더 시간이 걸린다.
- 이를 해결하기 위해 CPU 곁에 **TLB라는 페이지 테이블의 캐시 메모리**를 둔다.
- TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다.
- 참조 지역성을 근거해 주로 최근에 사용된 페이지 위주로 가져와서 저장한다.

#### 내부 단편화

- 페이징은 외부 단편화 문제를 해결할 수 있지만 *내부 단편화*라는 문제를 야기할 수 있다.
- 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생한다.
- 하나의 페이지를 작게 설정하면 내부 단편화도 해결되지만, 페이지의 크기를 너무 작게 설정하게 되면 그만큼 페이지 테이블의 크기도 커지기 때문에 공간이 낭비된다.

### 페이징에서의 주소 변환

- 하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있다.
- 그렇기에 특정 주소에 접근하려면 다음과 같은 정보가 필요하다. - 어떤 페이지 혹은 프레임에 접근하고 싶은지 - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
  그림
- 그렇기에 페이지 시스템에서는 모든 논리 주소가 기본적으로 *페이지 번호*와 *변위*로 이루어져 있다.
  - 페이지 번호 : 접근하고자 하는 페이지 번호
  - 변위 : 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지 알기 위한 정보
  - 논리 주소 <페이지 번호, 변위>는 물리 주소 <프레임 번호, 변위>로 변환된다.
    그림

### 페이지 테이블 엔트리

- 페이지 테이블의 각 엔트리, 다시 말해 페이지 테이블의 각각의 행들을 **페이지 테이블 엔트리**라고 한다.
- 유효 비트, 보호 비트, 참조 비트, 수정 비트와 같은 정보가 담긴다.
- **유효 비트** : 현재 해당 페이지에 접근 가능한지 여부를 알려준다. 즉,현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려주는 비트이다.
  - 유효하지 않은 페이지로 접근하려고 할때 **페이지 폴트**가 발생한다.
- **보호 비트** : 페이지 보호 기능을 위해 존재하는 비트이다. 해당 페이지가 모두 읽고 쓰기가 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있다.
  - 세 개의 비트로 조금 더 복잡하게 구현할 수도 있다.
  - 읽기(r), 쓰기(w), 실행(e) => 110 => 읽기, 쓰기 가능하지만 실행은 불가능
- **참조 비트** : CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다. 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 한 번도 읽거나 쓴적이 없는 페이지는 0으로 유지된다.
- **수정 비트** : 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다. *더티 비트*라고도 한다.
  - 페이지가 메모리에서 사라질 대 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재한다.

## 페이지 교체와 프레임 할당

- 운영체제는 프로세스들이 한정된 메모리를 효율적으로 이용할 수 있도록 기존에 메모리에 적재된 부릴요한 페이지를 선별하여 보조기억장치로 내보낼 수 있어야 하고, 프로세스에 적절한 수의 프레임을 할당하여 페이지를 할당할 수 있게 해야 한다.

### 요구 페이징

- 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법을 **요구 페이징**이라 한다.

1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
2. 해당 페이지가 현재 메모리에 있을 경우 CPU는 페이지가 적재된 프레임에 접근한다.
3. 해당 페이지가 현재 메모리에 없을 경우 페이지 폴트가 발생한다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 다시 1번을 수행한다.

- 위와 같은 요구 페이징 시스템이 안정적으로 작동하려면 필연적으로 **페이지 교체와 프레임 할당**을 해결해야 한다.
- 메모리에 적재된 많고 많은 페이지 중 어떤 페이지를 내보낼지 결정하는 방법을 _페이지 교체 알고리즘_ 이라고 한다.

### 페이지 교체 알고리즘

- 페이지 폴트를 가장 적게 일으키는 알고리즘으로 페이지 폴트 횟수를 알 수 있어야 한다.
- 이는 **페이지 참조열**을 통해 알 수 있다.
  - 페이지 참조열 : CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지 열을 의미한다.

#### FIFO 페이지 교체 알고리즘

- 메모리에 가장 먼저 올라온 페이지를 내쫓는 방식이다.
- 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있다.
- _2차 기회 페이지 교체 알고리즘_ : 이러한 부작용을 개선한 알고리즘으로, 페이지의 참조 비트가 1일 경우, 당장 내쫓지 않고 참조 비트를 0으로 만든 뒤 한 번 더 기회를 준다. 즉, CPU가 접근한 적이 있을 때(참조 비트:1) 기회를 한 번 더 주는 것이다.

#### 최적 페이지 교체 알고리즘

- CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다.
- 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.
- 가장 낮은 페이지 폴트율을 보장하는 알고리즘이지만, *'앞으로 오랫동안 사용되지 않을 페이지'*를 예측하기 힘들기 때문에 구현이 어렵다.

#### LRU 페이지 교체 알고리즘

- *오랫동안 사용되지 않은 페이지*를 교체하는 알고리즘이다.

### 스래싱과 프레임 할당

- 스래싱 : 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 말한다.
  그림
- 멀티프로그래밍의 정도가 높다면 현재 메모리에는 많은 프로세스가 동시에 실행 중이고, 낮다면 현재 메모리에는 적은 프로세스가 동시에 실행 중이다.
- 스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다.
- 운영체제는 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 한다.
- **프레임 할당 방식**
  - 정적 할당 방식
    - 균등할당 : 모든 프로세스에 균등하게 프레임을 제공하는 방식이지만, 합리적이지 않다.
    - 비례할당 : 프로세스 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠주는 방식으로 이또한 실제로 프로세스가 얼마나 많은 프레임이 필요한지 예측하기 힘들다는 단점이 있다.
  - 동적 할당 방식
    - 작업 집합 모델 : 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 *작업 집합*이라 하는데, 운영체제는 작업 집합의 크기만큼만 프레임을 할당해주면 된다.
    - 페이지 폴트 빈도 : 페이지 폴트율에 상한선과 하한선을 정하고 범위 안에서만 프레임을 할당하는 방식이다. 페이지 폴트율이 상한선보다 더 높아지면 그 프로세스는 너무 적은 프레임을 갖고 있고, 하한선보다 낮아지면 그 프로세스는 너무 많은 프레임을 갖고 있는 것이다. 이 경우 다른 프로세스에 할당하기 위해 프레임을 회수한다.
      그림
