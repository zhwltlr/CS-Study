## 소스코드와 명령어

모든 소스 코드는 컴퓨터 내부에서 명령어로 변환된다.

### 고급 언어와 저급 언어

- 프로그래밍 언어는 컴퓨터가 이해하는 언어가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어
  이를 **고급 언어**라고 한다.

- 반대로 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 **저급 언어**라고 한다
- 그렇기에 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 한다.

- 저급 언어는 기계어와 어셈블리어로 나뉜다
  - 기계어란 0과 1의 명령어 비트로 이루어진 언어
  - 사람이 읽으면 그 의미를 이해하기 어렵기 때문에 어셈블리어가 등장
  - 0과 1로 표현된 명령어를 일기 편한 형태로 번역한 언어가 어셈블리어
  - 어셈블리어를 이용해 복잡한 프로그램을 만들기란 쉽지 않기에 고급 언어가 필요

### 컴파일 언어와 인터프리터 언어

- 고급 언어가 저급 언어로 변환될 때, 컴파일 방식과 인터프리트 방식이 있다.

### 컴파일 언어

- 컴파일 언어는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어 ex. C
- 컴파일 언어로 작성된 소스 코드는 코드 전체가 저급 언어로 변환되는 과정을 거치는데 이를 **컴파일**이라 한다.
- 컴파일러는 소스 코드 전체를 훑어보며 문법적인 오류는 없는지, 실행 가능한 코드인지, 불필요한 코드는 없는지 등을 따지며 저급 언어로 컴파일
- 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패
- 컴파일러를 통해 저급 언어로 변환된 코드를 **_목적 코드_** 라고 한다

### 인터프리터 언어

- 인터프리터 언어는 소스 코드를 한줄씩 한줄씩 차례로 실행한다.
- 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 N번째 줄에 문법 오류가 있더라도 N-1번째 줄까지는 올바르게 수행

#### 컴파일 언어와 인터프리터 언어를 명확하게 구분한다?

- 경계가 모호한 경우가 많다.
- 파이썬은 대표적인 인터프리터 언어로 알려져 있으나 컴파일을 하지 않는 것은 아니다.
- 자바의 경우 저급 언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행한다.

### 목적 파일 vs 실행 파일

- 목적 코드로 이루어진 파일을 목적 파일이라고 한다.
- 실행 코드로 이루어진 파일을 실행 파일이라고 한다. ex. .exe 확장자

- 목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 한다.

  ![mainfile](https://github.com/zhwltlr/CS-Study/assets/100506719/f225ad8c-6a77-4bfe-a62d-98e81ead69ec)

  `main.c`는 `helper.c`에 구현된 `HELPER_더하기` 기능과 프로그래밍 언어가 기본으로 제공하는 `화면_출력`이라는 기능을 가져다 사용

  - 이들을 컴파일 하여 `helper.o`, `main.o` 라는 목적 파일이 만들어졌다고 가정
  - 저급 언어로 변환만 됐을 뿐 `HELPER_더하기` 및 `화면_출력` 기능을 어떻게 실행하는지는 알지 못한다.
  - 기능을 `main.o` 와 연결 짓는 작업이 필요한데 이를 **링킹**이라고 한다.

## 명령어의 구조

### 연산 코드와 오퍼랜드

- 컴퓨터 속 명령어는 '무엇을 대상으로, 어떤 작동을 수행하라'는 구조로 되어있다.
- 명령어는 연산 코드와 오퍼랜드로 구성
  - 연산 코드 : 명령어가 수행할 연산
    - 연산 코드 필드 : 연산 코드가 담기는 영역
  - 오퍼랜드 : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치
    - 오퍼랜드 코드 필드 : 오퍼랜드 코드가 담기는 영역

### 오퍼랜드

- 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다.
- 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.
  - 그래서 **주소 필드**라고 부르기도 한다.
- 오퍼랜드는 명령어 안에 하나도 없을 수도, 여러개가 있을 수도 있다.

### 연산 코드

- 데이터 전송 / 산술논리 연산 / 제어 흐름 변경 / 입출력 제어
- 명령어의 종류와 생김새는 CPU 마다 다르기 때문에 연산 코드의 종류와 생기새 또한 CPU마다 다르다.

### 주소 지정 방식

- **오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법**
- 하나의 명령어가 n 비트로 구성되어 있고, 연산 코드 필드가 m비트라고 가정
- 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할지라도 오퍼랜드 길이는 연산 코드만큼의 길이를 뺀 n-m비트가 된다.
- ex. 명령어 크기 16비트, 연산 코드 필드 4비트인 2-주소 명령어
  => 오버랜드 필드당 6비트가 남는다. 즉, 정보의 가짓수는 2의 6제곱개 밖에 안됨

- 하지만 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 잇는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.
- 레지스터 이름을 명시할 때도 해당 레지스터가 저장할 수 있는 공간만큼 커진다.

그림

- 연산 코드에 사용할 데이터가 저장된 위치, 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소**라고 한다.

- 현대 CPU는 다양한 주소 지정 방식을 사용한다.

  - 즉시 주소 지정 방식 : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식으로, 표현할 수 있는 데이터의 크기가 작아지지만 메모리나 레지스터로부터 찾는 과정이 없기 때문에 빠르게 진행된다.
    ![즉시주소](https://github.com/zhwltlr/CS-Study/assets/100506719/cbe24fa0-88bd-49d1-b560-f1f4031fca5f)
  - 직접 주소 지정 방식 : 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식으로, 표현할 수 있는 데이터의 크기는 더 커졌지만 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다.
    ![직접주소](https://github.com/zhwltlr/CS-Study/assets/100506719/f71e8b44-afa0-4579-8d03-be70d745d3c9)
  - 간접 주소 지정 방식 : 유효주소의 주소를 오퍼랜드 필드에 명시한다. 유효 주소의 범위가 더 넓어졌으나 두번의 메모리 접근이 필요하기 때문에 느리다.
    ![간접주소](https://github.com/zhwltlr/CS-Study/assets/100506719/05d5bac9-4f37-4ee8-9ade-cc389b9c3988)
  - 레지스터 주소 지정 방식 : 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법이다. 일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. 그러므로 직접 주소 지정 방식보다 빠르게 데이터에 접근 할 수 있지만, 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.
    ![레지스터주소](https://github.com/zhwltlr/CS-Study/assets/100506719/60bbcb21-cc2d-4f3c-b650-630a52de12f6)
  - 레지스터 간접 주소 지정 방식 : 연산에 사용할 데이터를 메모리에 저장하고 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다. 메모리에 접근하는 횟수가 한 번으로 줄어들기 때문에 간접 주소 지정 방식보다 빠르다.
    ![레지스터간접](https://github.com/zhwltlr/CS-Study/assets/100506719/91b53011-03be-4ad8-9e2b-bd0d5c21c7c6)

  | 방식                         | 오퍼랜드 필드에 명시하는 값 |
  | ---------------------------- | --------------------------- |
  | 즉시 주소 지정 방식          | 연산에 사용할 데이터        |
  | 직접 주소 지정 방식          | 유효 주소(메모리 주소)      |
  | 간접 주소 지정 방식          | 유효 주소의 주소            |
  | 레지스터 주소 지정 방식      | 유효 주소(레지스터 이름)    |
  | 레지스터 간접 주소 지정 방식 | 유효 주소를 저장한 레지스터 |

### 스택과 큐

- 스택은 한쪽 끝이 막혀 있어서 막혀있지 않은 쪽으로 데이터를 차곡차곡 저장하고, 저장한 자료를 빼낼 때는 마지막으로 저장한 데이터부터 빼낸다.

  - 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출)이라는 점에서 `LIFO 자료구조`라고도 한다.

- 큐는 한쪽으로는 데이터를 저장하고, 다른 한쪽으로는 먼저 저장한 순서대로 데이터를 빼낸다.
  - 가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식(선입선출)이라는 점에서 `FIFO 자료구조`라고도 한다.
