## 빠른 CPU를 위한 설계 기법

### 클럭

- 클럭 속도가 높은 CPU는 일반적으로 성능이 좋다.
- 클럭 속도는 CPU 속도 단위로 간주되기도 한다.
- 1초에 클럭이 몇 번 반복되는지 헤르츠 단위로 측정한다.
- 보통 고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도를 낮추기도 한다.
- 그렇다고 해서 클럭 속도를 무작정 높이면 발열 문제가 심화된다.

### 코어와 멀티코어

- 오늘날 CPU는 많은 기술적 발전을 거듭하여 '명령어를 실행하는 부품'을 얼마든지 만들 수 있게 되었다.
- 명령어를 실행하는 부품을 여러 개 포함하는 부품으로 명칭의 범위가 확장되었다.
- 코어를 여러 개 포함하고 있는 `멀티코어 CPU` 또는 `멀티코어 프로세서`라고 한다.
- ex. 싱글코어, 듀얼코어, 트리플코어등
- CPU의 연산 속도는 꼭 코어 수에 비례하여 증가하진 않는다.
- 코어마다 처리할 명령어들을 얼마나 적절하게 분배하는지가 문제이고 그에 따라 연산 속도는 크게 달라진다.

### 스레드와 멀티 스레드

- 스레드의 사전적 의미는 '실행 흐름의 단위'이다.
- 스레드에는 CPU에서 사용되는 `하드웨어적 스레드`가 있고, 프로그램에서 사용되는 `소프트웨어적 스레드`가 있다.
- 하드웨어적 스레드

  - 하드웨어적으로 정의하면 **하나의 코어가 동시에 처리하는 명령어 단위**를 의미한다.
  - ex. 2코어 4스레드 CPU는 명령어를 실행하는 부품을 두개 포함하고, 한번에 네개의 명령어를 처리할 수 있는 CPU를 의미한다. (**_멀티스레드 프로세서_**)

- 소프트웨어적 스레드

  - **하나의 프로그램에서 독립적으로 실행하는 단위**를 의미한다.
  - 하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램 여러 부분이 동시에 실행될 수도 있다.
    그림

- 멀티스레드 프로세서
  - 가장 큰 핵심은 레지스터이다.
  - 하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스텍 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개 갖고 있으면 된다.
    그림
  - ex. 2코어 4스레드 CPU는 한 번에 네 개의 명령어를 처리할 수 있는데, 프로그램 입장에서 봤을 땐 한 번에 하나의 명령어를 처리하는 CPU가 네개 있는 것처럼 보인다.
  - 그래서 _하드웨어 스레드를 논리 프로세서라고 부르기도 한다._

---

#### 코어는 명령어를 실행할 수 있는 *하드웨어 부품*이고, 스레드는 *명령어를 실행하는 단위*이다.

#### *멀티코어 프로세서*는 명령어를 실행할 수 있는 하드웨어 부품이 CPU안에 두개 이상 있는 CPU

#### *멀티스레드 프로세서*는 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

## 명령어 병렬 처리 기법

CPU를 한시도 쉬지 않고 작동시키는 기법인 명령어 병렬 처리 기법에는 **명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어** 처리가 있다.

### 명령어 파이프라이닝

명령어 처리 과정을 클럭 단위로 나누어 보면 일반적으로 다음과 같이 나눌 수 있다.

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장

- 같은 단계각 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다.
  그림
- 이처럼 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법을 명령어 파이프라이닝이라고 한다.
- 파이프라이닝이 높은 성능을 가져오긴 하지만, 성능향상에 실패하는 경우도 있다. 이를 *파이프라인 위험*이라고 부른다.
  - 데이터 위험 : 명령어 간 '데이터 의존성'에 의해 발생한다. 데이터 의존적인 두개 이상의 명령어를 동시에 실행하면, 모든 명령어를 동시에 처리할 수 없기 때문에 파이프라인이 제대로 작동하지 않는다.
  - 제어 위험 : 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생한다. 프로그램 실행 흐름이 바뀌어 명령어가 실행되면 미리 처리중이었던 명령어들이 쓸모가 없어진다.
  - 구조적 위험 : 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할때 발생하는 위험이다.

### 슈퍼스칼라

- 오늘날 대부분의 CPU에서는 여러 개의 파이프라인을 이용하는데 이러한 구조를 **슈퍼스칼라**라고 한다.
- 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 한다.
- 슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 한다.

### 비순차적 명령어 처리

- 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법이다.
- 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 비순차적 명령어 처리 기법이라고 한다.
  그림
- 비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지 판단할 수 있어야 한다.

## CISC와 RISC

- CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝 하기 쉽게 생겨야 한다.

### 명령어 집합

- CPU가 이해할 수 있는 명령어들의 모음을 **_명령어 집합_** 또는 **_명령어 집합 구조(ISA)_**라고 한다.
- ex. 인텔 노트북 속 CPU는 x86-64 ISA를 이해하고, 애플의 아이폰 속 CPU는 ARM ISA를 이해한다.서로의 컴퓨터가 이해할 수 있는 명령어가 다르다.
- ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻이고, 그러면 어셈블리어도 달라진다.
  그림
- ISA는 일종의 CPU의 언어인 셈이다.
- ISA가 다르면 제어장치가 명령어를 해석하는 방식, 상요되는 레지스터의 종류와 개수, 메모리 관리 방법등 많은 것이 달라진다.
  - _즉 ISA는 CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라고도 볼 수 있다._

### CISC

- CISC는 `Complex Instruction Set Computer`의 약자로 복잡한 명열어 집합을 활용하는 컴퓨터를 의미한다.
- CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용한다.
  - 이는 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다는 것을 의미한다.
  - 이 덕분에 메모리를 아끼며 개발해야 했던 시절에는 인기가 높았다.
  - 하지만 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기가 실행되기까지의 시간이 일정하지 않다.
  - 이렇게 되면 파이프라인이 효율적으로 명령어를 처리할 수 없게 된다.
  - 또한 대다수의 복잡한 명령어는 사용 빈도가 낮았다.

#### RISC

- RISC는 `Reduced Instruction Set Computer`의 약자로 CISC에 비해 명령어 종류가 적고 규격화된 명령어(되도록 1클럭 내외로 실행되는 명령어)를 지향한다.
- 즉 RISC는 **고정 길이 명령어**를 활용한다.
- 이는 명령어 파이프라이닝에 최적화 되어 있다.
- RISC는 메모리에 직접 접근하는 명령어를 load, store 두개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구한다.
- RISC는 메모리 접근을 단순화, 최소화하는 대신 *레지스터를 적극적으로 활용*한다.
- 그렇기에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다.
  그림
